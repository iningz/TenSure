import json
import os
import re
import sys


def to_finch_format(fmt):
    if fmt == "Dense":
        return "dense"
    if fmt == "Sparse":
        return "compressed"
    return "dense"


def convert(input_path, output_dir, result_file):
    try:
        with open(input_path, "r") as f:
            kernel = json.load(f)

        if not kernel.get("computations"):
            print("Error: No computations found in kernel spec")
            sys.exit(1)

        # Assume single computation
        expr = kernel["computations"][0]["expression"]
        # Remove spaces
        expr = expr.replace(" ", "")

        # Split LHS = RHS
        parts = expr.split("=")
        if len(parts) != 2:
            print(f"Error: Invalid expression format: {expr}")
            sys.exit(1)

        lhs, rhs = parts

        # Parse LHS: Name(indices)
        match = re.match(r"(\w+)\(([\w,]+)\)", lhs)
        if not match:
            print(f"Error: Invalid LHS format: {lhs}")
            sys.exit(1)

        out_name = match.group(1)
        out_indices = match.group(2)
        out_indices_clean = out_indices.replace(",", "")

        # Find tensor spec
        tensors = {t["name"]: t for t in kernel["tensors"]}
        if out_name not in tensors:
            print(f"Error: Output tensor {out_name} not defined in tensors list")
            sys.exit(1)

        out_tensor = tensors[out_name]

        out_obj = {
            "name": out_name,
            "file": os.path.abspath(result_file),
            "format": [to_finch_format(f) for f in out_tensor["storageFormat"]],
        }

        # Parse RHS: Term * Term ...
        input_terms = rhs.split("*")
        inputs_arr = []
        input_einsum_parts = []

        for term in input_terms:
            match = re.match(r"(\w+)\(([\w,]+)\)", term)
            if not match:
                print(f"Error: Invalid RHS term format: {term}")
                sys.exit(1)

            name = match.group(1)
            indices = match.group(2)
            indices_clean = indices.replace(",", "")
            input_einsum_parts.append(indices_clean)

            if name not in tensors:
                print(f"Error: Input tensor {name} not defined in tensors list")
                sys.exit(1)

            t = tensors[name]

            # Data file logic
            data_file = t.get("dataFile", "")

            # If path is relative, make it absolute relative to CWD (as the runner does)
            if data_file and data_file != "-":
                data_file = os.path.abspath(data_file)
            else:
                data_file = ""

            inputs_arr.append(
                {
                    "name": name,
                    "file": data_file,
                    "format": [to_finch_format(f) for f in t["storageFormat"]],
                }
            )

        einsum_str = f"{','.join(input_einsum_parts)}->{out_indices_clean}"

        spec = {
            "kernel_0": {
                "desc": "Generated by TenSure Finch Wrapper",
                "einsum": einsum_str,
                "inputs": inputs_arr,
                "output": out_obj,
            }
        }

        os.makedirs(output_dir, exist_ok=True)
        with open(os.path.join(output_dir, "kernel.json"), "w") as f:
            json.dump(spec, f, indent=4)

    except Exception as e:
        print(f"Error converting kernel: {e}")
        sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) < 4:
        print(
            "Usage: python3 convert_kernel.py <input_json> <output_dir> <result_file>"
        )
        sys.exit(1)

    convert(sys.argv[1], sys.argv[2], sys.argv[3])
